<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Tracking for Field Staff</title>  
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow-x: hidden; /* Remove horizontal scrollbar */
            overflow-y: auto; /* Add vertical scrollbar */
            min-height: 100vh; /* Minimum viewport height */
            display: flex;
            flex-direction: column;
        }
        
        .header {
            text-align: center;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }
        
        .header h1 {
            margin: 0;
            font-size: 3rem;
            font-weight: bold;
            color: #3498db;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .header p {
            margin: 5px 0 0 0;
            font-size: 1.2rem;
            color: #ecf0f1;
        }
        
        .main-container {
            display: flex;
            flex: 1;
            gap: 20px;
            padding: 15px 20px;
            overflow: hidden;
        }
        
        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            color: #333;
            overflow: hidden; /* Hide scrollbars */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }
        
        .staff-info {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #ecf0f1;
        }
        
        .staff-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(45deg, #3498db, #2ecc71);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            margin-right: 15px;
        }
        
        .staff-details h3 {
            margin: 0;
            color: #2c3e50;
        }
        
        .staff-details p {
            margin: 2px 0;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        .status-online {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: #2ecc71;
            border-radius: 50%;
            margin-left: 10px;
        }
        
        .timeline {
            max-height: 400px;
            overflow-y: auto; /* Internal scrolling for timeline content only */
            overflow-x: hidden;
            padding-right: 5px; /* Space for scrollbar */
        }
        
        .timeline-item {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(248, 249, 250, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .timeline-marker {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .timeline-marker.start { background: #2ecc71; }
        .timeline-marker.checkpoint { background: #3498db; }
        .timeline-marker.end { background: #e74c3c; }
        
        .timeline-content {
            flex: 1;
        }
        
        .timeline-content h4 {
            margin: 0 0 3px 0;
            color: #1a1a1a;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .timeline-content p {
            margin: 1px 0;
            color: #444444;
            font-size: 0.75rem;
            line-height: 1.3;
        }
        
        #map {
            flex: 1;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .recenter-button {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 1000;
            background: linear-gradient(45deg, #3498db, #2ecc71);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            color: white;
            font-size: 18px;
        }
        
        .recenter-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(45deg, #2980b9, #27ae60);
        }
        
        .recenter-button:active {
            transform: scale(0.95);
        }
        
        .recenter-button::before {
            content: '🎯';
            font-size: 20px;
        }
        
        .add-place-button {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 1000;
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            color: white;
            font-size: 24px;
            font-weight: bold;
        }
        
        .add-place-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(45deg, #27ae60, #229954);
        }
        
        .add-place-button:active {
            transform: scale(0.95);
        }
        
        .add-place-button::before {
            content: '+';
            font-size: 28px;
            line-height: 1;
        }
        
        .summary-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: linear-gradient(45deg, #3498db, #2ecc71);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            color: white;
        }
        
        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.8rem;
            opacity: 0.9;
        }
        
        /* Responsive Design - Mobile First */
        
        /* Tablet Styles (768px - 1024px) */
        @media screen and (max-width: 1024px) {
            .sidebar {
                width: 300px;
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }
            
            .main-container {
                gap: 15px;
                padding: 15px;
            }
            
            .timeline {
                max-height: none;
                min-height: 40vh;
            }
        }
        
        /* Mobile Styles (max-width: 768px) */
        @media screen and (max-width: 768px) {
            .header {
                padding: 12px 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            .main-container {
                flex-direction: column;
                gap: 12px;
                padding: 10px;
            }
            
            .sidebar {
                width: 100%;
                order: 2;
                max-height: none;
                padding: 15px;
                flex-shrink: 0;
                min-height: 60vh;
                margin: 0 auto;
                box-sizing: border-box;
            }
            
            #map {
                order: 1;
                flex: 1;
                min-height: 65vh;
                max-height: 70vh;
            }
            
            .summary-stats {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                margin-bottom: 15px;
            }
            
            .stat-card {
                padding: 12px 8px;
            }
            
            .stat-number {
                font-size: 1.3rem;
            }
            
            .stat-label {
                font-size: 0.75rem;
            }
            
            .staff-info {
                margin-bottom: 15px;
                padding-bottom: 12px;
            }
            
            .staff-avatar {
                width: 45px;
                height: 45px;
                margin-right: 12px;
            }
            
            .staff-details h3 {
                font-size: 0.95rem;
            }
            
            .staff-details p {
                font-size: 0.8rem;
            }
            
            .timeline {
                max-height: 250px;
            }
            
            .timeline-marker {
                width: 25px;
                height: 25px;
                font-size: 11px;
                margin-right: 12px;
            }
            
            .timeline-content h4 {
                font-size: 0.85rem;
            }
            
            .timeline-content p {
                font-size: 0.75rem;
            }
            
            .recenter-button {
                width: 45px;
                height: 45px;
                top: 10px;
                right: 10px;
            }
            
            .recenter-button::before {
                font-size: 16px;
            }
            
            .add-place-button {
                width: 50px;
                height: 50px;
                bottom: 10px;
                right: 10px;
            }
            
            .add-place-button::before {
                font-size: 22px;
            }
        }
        
        /* Small Mobile Styles (max-width: 480px) */
        @media screen and (max-width: 480px) {
            .header {
                padding: 10px 8px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .header p {
                font-size: 0.9rem;
            }
            
            .main-container {
                padding: 8px;
                gap: 8px;
            }
            
            .sidebar {
                padding: 12px;
                border-radius: 10px;
                max-height: 35vh;
                min-height: 180px;
                margin: 0 auto;
                box-sizing: border-box;
            }
            
            #map {
                border-radius: 10px;
                min-height: 70vh;
                max-height: 75vh;
            }
            
            .summary-stats {
                gap: 6px;
            }
            
            .stat-card {
                padding: 10px 6px;
                border-radius: 8px;
            }
            
            .stat-number {
                font-size: 1.2rem;
            }
            
            .staff-avatar {
                width: 40px;
                height: 40px;
                margin-right: 10px;
            }
            
            .staff-details h3 {
                font-size: 0.9rem;
            }
            
            .staff-details p {
                font-size: 0.75rem;
            }
            
            .timeline-marker {
                width: 22px;
                height: 22px;
                font-size: 10px;
                margin-right: 10px;
            }
            
            .timeline-content h4 {
                font-size: 0.8rem;
            }
            
            .timeline-content p {
                font-size: 0.7rem;
            }
            
            .timeline {
                max-height: 200px;
            }
            
            .recenter-button {
                width: 40px;
                height: 40px;
                top: 8px;
                right: 8px;
            }
            
            .recenter-button::before {
                font-size: 14px;
            }
            
            .add-place-button {
                width: 45px;
                height: 45px;
                bottom: 8px;
                right: 8px;
            }
            
            .add-place-button::before {
                font-size: 20px;
            }
        }
        
        /* Extra Small Mobile Styles (max-width: 320px) */
        @media screen and (max-width: 320px) {
            .header {
                padding: 8px;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .header p {
                font-size: 0.8rem;
            }
            
            .main-container {
                padding: 6px;
                gap: 6px;
            }
            
            .sidebar {
                max-height: 30vh;
                min-height: 150px;
                padding: 10px;
                margin: 0 auto;
                box-sizing: border-box;
            }
            
            #map {
                min-height: 75vh;
                max-height: 80vh;
            }
            
            .summary-stats {
                grid-template-columns: 1fr;
                gap: 6px;
            }
            
            .stat-card {
                padding: 10px;
            }
            
            .recenter-button {
                width: 35px;
                height: 35px;
                top: 6px;
                right: 6px;
            }
            
            .recenter-button::before {
                font-size: 12px;
            }
            
            .add-place-button {
                width: 40px;
                height: 40px;
                bottom: 6px;
                right: 6px;
            }
            
            .add-place-button::before {
                font-size: 18px;
            }
        }
        
        /* Landscape Mobile Orientation */
        @media screen and (max-height: 500px) and (orientation: landscape) {
            .header {
                padding: 6px 10px;
            }
            
            .header h1 {
                font-size: 1.4rem;
            }
            
            .header p {
                font-size: 0.75rem;
            }
            
            .main-container {
                flex-direction: row;
                padding: 8px;
                gap: 10px;
            }
            
            .sidebar {
                width: 280px;
                order: 1;
                max-height: none;
                min-height: 0;
                flex: 0 0 280px;
            }
            
            #map {
                order: 2;
                flex: 1;
                min-height: 0;
                max-height: none;
            }
        }
        
        /* Tablet Landscape Specific */
        @media screen and (min-width: 768px) and (max-height: 600px) and (orientation: landscape) {
            .sidebar {
                width: 300px;
                flex: 0 0 300px;
            }
        }
        
        /* Animation for marker pop effect */
        @keyframes markerPop {
            0% { 
                transform: scale(0) rotate(45deg); 
                opacity: 0; 
            }
            50% { 
                transform: scale(1.3) rotate(0deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: scale(1) rotate(0deg); 
                opacity: 1; 
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>TRACE THE PATH</h1>
        <p>FOR BOOTH LEVEL OFFICERS</p>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="staff-info">
                <div class="staff-avatar">MK</div>
                <div class="staff-details">
                    <h3>Mahesh Kumar <span class="status-online"></span></h3>
                    <p>ID 120999 | Booth level officer</p>
                    <p>Kalyanpur G.P, Bhubaneswar Block</p>
                </div>
            </div>
            
            <div class="summary-stats">
                <div class="stat-card">
                    <div class="stat-number" id="total-stops">0</div>
                    <div class="stat-label">Total Stops</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="total-photos">0</div>
                    <div class="stat-label">Photos Taken</div>
                </div>
            </div>
            
            <h4 style="color: #2c3e50; margin-bottom: 15px;">📍 Movement Timeline</h4>
            <div class="timeline" id="timeline">
                <!-- Timeline items will be populated by JavaScript -->
            </div>
        </div>
        
        <div id="map">
            <button class="recenter-button" id="recenterBtn" title="Recenter Map"></button>
            <button class="add-place-button" id="addPlaceBtn" title="Add New Place"></button>
        </div>
    </div>
    
    <script>
        // Initialize the map when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Create the map (we'll adjust the view after loading data)
            const map = L.map('map').setView([20.2961, 85.8245], 12);
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
            
            // Load the JSON data and plot markers
            fetch('./bhubaneswar_block_data.json')
                .then(response => response.json())
                .then(jsonData => {
                    const data = jsonData.data;
                    const markers = [];
                    const routePoints = [];
                    
                    // Sort locations by date/time to create proper route sequence
                    const sortedData = data.slice().sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));
                    
                    // Prepare route points for animation
                    sortedData.forEach((location, index) => {
                        let longitude = location.longitude;
                        if (location.id === 1 && longitude === 20.296059) {
                            longitude = 85.824500; // Corrected longitude for Bhubaneswar
                        }
                        routePoints.push([location.latitude, longitude]);
                    });
                    
                    // Animation variables
                    let currentMarkerIndex = 0;
                    let animationRunning = false;
                    
                    // Function to create a single marker with animation
                    function createAnimatedMarker(location, index) {
                        let longitude = location.longitude;
                        if (location.id === 1 && longitude === 20.296059) {
                            longitude = 85.824500;
                        }
                        
                        const lat = location.latitude;
                        const lng = longitude;
                        
                        // Create different marker colors based on sequence
                        let markerColor = 'blue';
                        if (index === 0) markerColor = 'green'; // Start point
                        if (index === sortedData.length - 1) markerColor = 'red'; // End point
                        
                        // Create custom marker with color and sequence number
                        const marker = L.marker([lat, lng], {
                            icon: L.divIcon({
                                className: 'custom-marker',
                                html: `
                                    <div style="position: relative;">
                                        <div style="
                                            width: 25px; 
                                            height: 25px; 
                                            border-radius: 50%; 
                                            background: ${markerColor}; 
                                            border: 3px solid white; 
                                            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                                            display: flex; 
                                            align-items: center; 
                                            justify-content: center; 
                                            font-weight: bold; 
                                            font-size: 12px;
                                            color: white;
                                            cursor: pointer;
                                            animation: markerPop 0.6s ease-out;
                                        ">${index + 1}</div>
                                    </div>
                                `,
                                iconSize: [25, 25],
                                iconAnchor: [12, 12]
                            })
                        }).addTo(map);
                        
                        // Format the date/time
                        const dateTime = new Date(location.dateTime).toLocaleString();
                        
                        // Create popup content with sequence number
                        const popupContent = `
                            <div style="max-width: 250px;">
                                <h4 style="margin: 0 0 10px 0; color: #333;">Stop #${index + 1} - ID: ${location.id}</h4>
                                <p style="margin: 5px 0;"><strong>Address:</strong><br>${location.addressDetail}</p>
                                <p style="margin: 5px 0;"><strong>Landmark:</strong> ${location.landmark}</p>
                                <p style="margin: 5px 0;"><strong>Time:</strong> ${dateTime}</p>
                                <p style="margin: 5px 0;"><strong>Updated By:</strong> ${location.updatedBy}</p>
                                <p style="margin: 5px 0;"><strong>Photos:</strong> ${location.photos.length} photo(s)</p>
                                <p style="margin: 5px 0; color: ${markerColor}; font-weight: bold;">
                                    ${index === 0 ? '🟢 START' : index === sortedData.length - 1 ? '🔴 END' : '🔵 CHECKPOINT'}
                                </p>
                            </div>
                        `;
                        
                        marker.bindPopup(popupContent);
                        markers.push(marker);
                        
                        // Open popup for first marker
                        if (index === 0) {
                            setTimeout(() => {
                                marker.openPopup();
                            }, 200); // Faster popup delay (reduced from 300ms)
                        }
                        
                        return marker;
                    }
                    
                    // Function to update timeline highlighting
                    function updateTimelineHighlight(activeIndex) {
                        const timelineItems = document.querySelectorAll('.timeline-item');
                        timelineItems.forEach((item, index) => {
                            if (index === activeIndex) {
                                item.style.background = 'linear-gradient(45deg, #3498db, #2ecc71)';
                                item.style.color = 'white';
                                item.style.borderRadius = '10px';
                                item.style.padding = '10px';
                                item.style.transform = 'scale(1.02)';
                                item.style.transition = 'all 0.3s ease';
                            } else if (index < activeIndex) {
                                item.style.background = '#ecf0f1';
                                item.style.color = '#7f8c8d';
                                item.style.borderRadius = '5px';
                                item.style.padding = '5px';
                                item.style.transform = 'scale(1)';
                                item.style.transition = 'all 0.3s ease';
                            } else {
                                item.style.background = 'transparent';
                                item.style.color = '#333';
                                item.style.borderRadius = '0';
                                item.style.padding = '0';
                                item.style.transform = 'scale(1)';
                                item.style.transition = 'all 0.3s ease';
                            }
                        });
                    }
                    
                    // Function to create route between two points
                    async function createRouteBetweenPoints(fromIndex, toIndex) {
                        const start = routePoints[fromIndex];
                        const end = routePoints[toIndex];
                        
                        try {
                            // Use OSRM for road routing
                            const response = await fetch(
                                `https://router.project-osrm.org/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson`
                            );
                            
                            if (response.ok) {
                                const data = await response.json();
                                if (data.routes && data.routes.length > 0) {
                                    const routeGeometry = data.routes[0].geometry.coordinates;
                                    const segmentCoords = routeGeometry.map(coord => [coord[1], coord[0]]);
                                    
                                    // Create route line
                                    const routeLine = L.polyline(segmentCoords, {
                                        color: '#e74c3c',
                                        weight: 4,
                                        opacity: 0.8,
                                        lineJoin: 'round'
                                    }).addTo(map);
                                    
                                    // Add route info
                                    const distance = (data.routes[0].distance / 1000).toFixed(1);
                                    const duration = Math.round(data.routes[0].duration / 60);
                                    
                                    routeLine.bindPopup(`
                                        <div style="text-align: center;">
                                            <h4 style="margin: 0 0 5px 0; color: #e74c3c;">Route ${fromIndex + 1} → ${toIndex + 1}</h4>
                                            <p style="margin: 2px 0;"><strong>Distance:</strong> ${distance} km</p>
                                            <p style="margin: 2px 0;"><strong>Duration:</strong> ${duration} mins</p>
                                        </div>
                                    `);
                                    
                                    console.log(`Route ${fromIndex + 1} → ${toIndex + 1}: ${distance}km, ${duration}min`);
                                    return routeLine;
                                }
                            }
                        } catch (error) {
                            console.warn(`Could not get road route, using direct path`);
                        }
                        
                        // Fallback to straight line
                        const directRoute = L.polyline([start, end], {
                            color: '#e74c3c',
                            weight: 3,
                            opacity: 0.6,
                            dashArray: '10, 5'
                        }).addTo(map);
                        
                        return directRoute;
                    }
                    
                    // Main sequential animation function
                    async function startSequentialAnimation() {
                        if (animationRunning || currentMarkerIndex >= sortedData.length) return;
                        
                        animationRunning = true;
                        console.log(`Showing marker ${currentMarkerIndex + 1}`);
                        
                        // Create current marker with animation
                        const marker = createAnimatedMarker(sortedData[currentMarkerIndex], currentMarkerIndex);
                        
                        // Update timeline highlighting
                        updateTimelineHighlight(currentMarkerIndex);
                        
                        // Update stats
                        document.getElementById('total-stops').textContent = currentMarkerIndex + 1;
                        
                        // Center map on current marker
                        map.setView([routePoints[currentMarkerIndex][0], routePoints[currentMarkerIndex][1]], 15, {
                            animate: true,
                            duration: 0.7 // Faster camera movement (reduced from 1.0)
                        });
                        
                        // If there's a next marker, create route to it after a delay
                        if (currentMarkerIndex < sortedData.length - 1) {
                            setTimeout(async () => {
                                console.log(`Creating route from marker ${currentMarkerIndex + 1} to marker ${currentMarkerIndex + 2}`);
                                
                                // Close popup from current marker before moving to next
                                map.closePopup();
                                
                                // Create route to next marker
                                await createRouteBetweenPoints(currentMarkerIndex, currentMarkerIndex + 1);
                                
                                // Move to next marker
                                currentMarkerIndex++;
                                animationRunning = false;
                                
                                // Continue animation with delay
                                setTimeout(() => {
                                    startSequentialAnimation();
                                }, 800); // Faster delay after route creation (reduced from 1500ms)
                            }, 1200); // Faster delay before route creation (reduced from 2000ms)
                        } else {
                            // Animation complete - fit map to show all markers
                            animationRunning = false;
                            setTimeout(() => {
                                if (markers.length > 0) {
                                    const group = new L.featureGroup(markers);
                                    map.fitBounds(group.getBounds().pad(0.1), {
                                        animate: true,
                                        duration: 1.5
                                    });
                                }
                            }, 2000);
                        }
                    }
                    
                    // Create proper road routes following actual paths
                    async function createRoadRoutes() {
                        if (routePoints.length < 2) return;
                        
                        const allRouteCoords = [];
                        
                        for (let i = 0; i < routePoints.length - 1; i++) {
                            const start = routePoints[i];
                            const end = routePoints[i + 1];
                            
                            try {
                                // Use OSRM (Open Source Routing Machine) - free routing service
                                const response = await fetch(
                                    `https://router.project-osrm.org/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson`
                                );
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    if (data.routes && data.routes.length > 0) {
                                        const routeGeometry = data.routes[0].geometry.coordinates;
                                        
                                        // Convert coordinates from [lng, lat] to [lat, lng] for Leaflet
                                        const segmentCoords = routeGeometry.map(coord => [coord[1], coord[0]]);
                                        allRouteCoords.push(...segmentCoords);
                                        
                                        // Create route segment
                                        const routeSegment = L.polyline(segmentCoords, {
                                            color: '#e74c3c',
                                            weight: 4,
                                            opacity: 0.8,
                                            lineJoin: 'round'
                                        }).addTo(map);
                                        
                                        // Add route info
                                        const distance = (data.routes[0].distance / 1000).toFixed(1);
                                        const duration = Math.round(data.routes[0].duration / 60);
                                        
                                        routeSegment.bindPopup(`
                                            <div style="text-align: center;">
                                                <h4 style="margin: 0 0 5px 0; color: #e74c3c;">Route Segment ${i + 1}</h4>
                                                <p style="margin: 2px 0;"><strong>Distance:</strong> ${distance} km</p>
                                                <p style="margin: 2px 0;"><strong>Duration:</strong> ${duration} mins</p>
                                                <p style="margin: 2px 0; font-size: 0.8rem;">Stop ${i + 1} → Stop ${i + 2}</p>
                                            </div>
                                        `);
                                        
                                        console.log(`Route ${i + 1}: ${distance}km, ${duration}min`);
                                    }
                                } else {
                                    throw new Error('Routing service unavailable');
                                }
                            } catch (error) {
                                console.warn(`Could not get road route for segment ${i + 1}, using direct path`);
                                
                                // Fallback to straight line if routing fails
                                const directRoute = L.polyline([start, end], {
                                    color: '#e74c3c',
                                    weight: 3,
                                    opacity: 0.6,
                                    dashArray: '10, 5',
                                    lineJoin: 'round'
                                }).addTo(map);
                                
                                directRoute.bindPopup(`
                                    <div style="text-align: center;">
                                        <h4 style="margin: 0 0 5px 0; color: #e74c3c;">Direct Route ${i + 1}</h4>
                                        <p style="margin: 2px 0; font-size: 0.8rem;">Straight line connection</p>
                                        <p style="margin: 2px 0; font-size: 0.8rem;">Stop ${i + 1} → Stop ${i + 2}</p>
                                    </div>
                                `);
                                
                                allRouteCoords.push(...[start, end]);
                            }
                            
                            // Small delay to avoid overwhelming the service
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        
                        // Add direction arrows along the complete route
                        if (allRouteCoords.length > 0) {
                            const arrowInterval = Math.max(1, Math.floor(allRouteCoords.length / 8));
                            
                            for (let i = arrowInterval; i < allRouteCoords.length - arrowInterval; i += arrowInterval) {
                                const current = allRouteCoords[i];
                                const next = allRouteCoords[i + 1] || allRouteCoords[i];
                                
                                if (current && next) {
                                    const angle = Math.atan2(next[1] - current[1], next[0] - current[0]) * 180 / Math.PI + 90;
                                    
                                    L.marker(current, {
                                        icon: L.divIcon({
                                            className: 'route-arrow',
                                            html: `<div style="transform: rotate(${angle}deg); color: #e74c3c; font-size: 14px; text-shadow: 1px 1px 1px white;">➤</div>`,
                                            iconSize: [14, 14],
                                            iconAnchor: [7, 7]
                                        })
                                    }).addTo(map);
                                }
                            }
                        }
                    }
                    
                    // Start sequential animation automatically after a short delay
                    setTimeout(() => {
                        console.log('Starting sequential marker animation...');
                        startSequentialAnimation();
                    }, 600); // Faster start delay (reduced from 1000ms)
                    
                    // Populate the timeline sidebar
                    const timeline = document.getElementById('timeline');
                    let totalPhotos = 0;
                    
                    sortedData.forEach((location, index) => {
                        totalPhotos += location.photos.length;
                        
                        const time = new Date(location.dateTime);
                        const timeString = time.toLocaleTimeString('en-US', { 
                            hour: '2-digit', 
                            minute: '2-digit',
                            hour12: true 
                        });
                        
                        let markerClass = 'checkpoint';
                        let statusIcon = '📍';
                        let statusText = 'Meeting';
                        
                        if (index === 0) {
                            markerClass = 'start';
                            statusIcon = '🟢';
                            statusText = 'Sign in';
                        } else if (index === sortedData.length - 1) {
                            markerClass = 'end';
                            statusIcon = '🔴';
                            statusText = 'Sign out';
                        }
                        
                        const timelineItem = `
                            <div class="timeline-item">
                                <div class="timeline-marker ${markerClass}">${index + 1}</div>
                                <div class="timeline-content">
                                    <h4>${statusIcon} ${statusText} at ${timeString}</h4>
                                    <p><strong>${location.landmark}</strong></p>
                                    <p>${location.addressDetail}</p>
                                    <p style="color: #3498db;">📸 ${location.photos.length} photo(s) taken</p>
                                </div>
                            </div>
                        `;
                        
                        timeline.innerHTML += timelineItem;
                    });
                    
                    // Update summary stats
                    document.getElementById('total-stops').textContent = sortedData.length;
                    document.getElementById('total-photos').textContent = totalPhotos;
                    
                    // Set up recenter button functionality (always available)
                    const recenterBtn = document.getElementById('recenterBtn');
                    recenterBtn.addEventListener('click', function() {
                        // If we have markers, fit to all markers
                        if (markers.length > 0) {
                            const group = new L.featureGroup(markers);
                            const bounds = group.getBounds().pad(0.1);
                            map.fitBounds(bounds, {
                                padding: [20, 20],
                                duration: 1.0,
                                easeLinearity: 0.5
                            });
                        } else {
                            // Fallback: fit to all route points
                            if (routePoints.length > 0) {
                                const bounds = L.latLngBounds(routePoints);
                                map.fitBounds(bounds.pad(0.1), {
                                    padding: [20, 20],
                                    duration: 1.0,
                                    easeLinearity: 0.5
                                });
                            }
                        }
                        
                        // Visual feedback
                        recenterBtn.style.transform = 'scale(0.9)';
                        setTimeout(() => {
                            recenterBtn.style.transform = 'scale(1)';
                        }, 150);
                        
                        console.log('Map recentered to show all locations');
                    });
                    
                    // Set up add place button functionality
                    const addPlaceBtn = document.getElementById('addPlaceBtn');
                    addPlaceBtn.addEventListener('click', function() {
                        // Visual feedback
                        addPlaceBtn.style.transform = 'scale(0.9)';
                        setTimeout(() => {
                            addPlaceBtn.style.transform = 'scale(1)';
                            // Redirect to addPlace.html
                            window.location.href = './addPlace.html';
                        }, 150);
                        
                        console.log('Redirecting to Add Place page');
                    });
                    
                    // Fit the map to show all markers (only if any exist)
                    if (markers.length > 0) {
                        const group = new L.featureGroup(markers);
                        const bounds = group.getBounds().pad(0.1);
                        map.fitBounds(bounds);
                        
                        // Store bounds globally for recenter functionality
                        window.mapBounds = bounds;
                    }
                    
                    console.log(`Loaded ${data.length} field staff locations with route tracking`);
                })
                .catch(error => {
                    console.error('Error loading location data:', error);
                    // Fallback to default location if JSON fails to load
                    const defaultMarker = L.marker([20.2961, 85.8245]).addTo(map);
                    defaultMarker.bindPopup('Default Location - Bhubaneswar').openPopup();
                });
        });
    </script>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
</body>
</html> 